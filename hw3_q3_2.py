import numpy as np
import matplotlib.pyplot as plt
##本代码对应第三大题第二小题
x=np.array([[0.68,1.34],[0.93,0.89],[0.9,1.66],[1.08,0.65],[1.26,0.57],
           [0.91,1.51],[1.5,1.26],[1.26,1.31],[0.92,1.26],[1.04,0.99],
           [-0.99,-1.54],[-1.16,-1.23],[-0.77,-1.01],[-1.3,-1.28],[-1.27,-0.96],
           [-0.99,-1.13],[-0.94,-0.93],[-1.21,-0.99],[-1.71,-0.82],[-0.99,-0.92],
           [0.99,-0.6],[1.03,-1.08],[1.56,-0.98],[1.26,-1.16],[1.14,-0.8],
           [0.9,-1.25],[1.18,-0.7],[1.3,-0.9],[1.42,-0.82],[0.54,-1.2],
           [-0.78,0.68],[-1.02,1.29],[-0.84,1.12],[-0.73,1.06],[-0.54,1.0],
           [-1.14,0.58],[1.09,0.51],[-1.12,1.33],[-0.14,0.82],[-1.45,1.31]])
t=np.array([[1,0],[1,0],[1,0],[1,0],[1,0],[1,0],[1,0],[1,0],[1,0],[1,0],
           [1,0],[1,0],[1,0],[1,0],[1,0],[1,0],[1,0],[1,0],[1,0],[1,0],
           [0,1],[0,1],[0,1],[0,1],[0,1],[0,1],[0,1],[0,1],[0,1],[0,1],
           [0,1],[0,1],[0,1],[0,1],[0,1],[0,1],[0,1],[0,1],[0,1],[0,1]])
##通过切片将样本数据分为两组
x1=x[:20]
x2=x[20:40]
##以下两个数组用于记录
rex=[]
rey=[]
##下列过程基本照搬之前的罗杰斯特回归的代码，除了增广向量处不同外其它基本相似
def sigmoid(x):#sigmoid函数
    return 1/(1+np.exp(-x))
def yinx(w,x):#条件概率
    return sigmoid(np.dot(x,w))
def logistic(x1,x2):
    x3=np.ones((20,2))
    x4=np.ones((20,2))
    ##增广向量：加入乘积项以及末尾的常数项
    for i in range(20):
        x3[i][0]=x1[i][0]*x1[i][1]
        x3[i][1]=1
    for i in range(20):
        x4[i][0]=x2[i][0]*x2[i][1]
        x4[i][1]=1
    x5=np.hstack((x1,x3))
    x6=np.hstack((x2,x4))
    for j in range(0,100):
        rate=j/100
        loss=0
        w=np.array([0.0,0.0,0.0,0.0])#w为判别向量，下为罗杰斯特回归过程
        for time in range(0,10000):
            count=np.array([0.0,0.0,0.0,0.0])
            for i in range(0,10):
                count+=x5[i]*(yinx(w,x5[i])-1)
                count+=x6[i]*(yinx(w,x6[i]))
            w-=rate*count
        ##计算损失函数并将其记录
        for i in range(20):
            loss+=(yinx(w,x5[i])-1)**2
        for i in range(20):
            loss+=(yinx(w,x6[i]))**2
        rex.append(rate)
        rey.append(loss)
logistic(x1,x2)
plt.plot(rex,rey,'blue')
plt.xlim(0,1)
plt.xlabel("learningrate")
plt.ylabel("loss")
plt.show()